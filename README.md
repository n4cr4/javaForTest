# 変数宣言
配列はクセがあるので注意．
Clarify.java参照
```Java
int a;
double b;
String msg = "hello";
System.out.println(msg);
int[] array = new int[4];
// int[] array = {0, 1, 2, 3};
array[0] = 0;
array[1] = 1;
array[2] = 2;
array[3] = 3;

for(int i=0; i<array.length; i++){
    System.out.Printf("out array: %d", array[i]);
}
```
# メソッド
C言語でいうところの関数、
ただし関数は必要な値などを基本的に
引数から受け取るのに対してメソッドはクラスに
属しているのでクラス内の値も用いた動作が可能な点に注意．
Method.java参照
```Java
class Clarify{
    public static void main(String[] args){
        int[] array = {0, 1, 2, 3};
        for(int i=0; i<array.length; i++){
            System.out.printf("out array: %d\n", array[i]);
        }
    }
}
```
# オブジェクト指向プログラミング
プログラムのまとまり(変数+関数)をオブジェクトとして
扱う．類似のオブジェクトを作成したり同じ種類のオブジェクトを複数作成しやすい．  
Object.java、Person.java参照．
# カプセル化
大規模なプログラム開発において変数がどこからアクセス可能かは非常に大切．
オブジェクト内部での変数(フィールド変数)やメソッドの中でも外部からアクセスする必要の
ないものは、クラスの外に公開しない(隠す)．
# クラス
オブジェクト(変数+関数)の定義
# インスタンス(実体)
`new`演算子で実際にメモリを割り当てたオブジェクト．
# セッター、ゲッター
カプセル化を行えばクラス外部からのアクセスを防ぐことができる．
しかしこれではインスタンス化した後でもオブジェクトの内部要素にアクセスする必要が
あるときに不便．そこでセッター、ゲッター(アクセサメソッドとも呼ばれる)を実装することで
明示的に変数にアクセスさせることができる．
* セッターは変数に値を書き込む機能を持つメソッド．バリデーション(値の妥当性の確認)ができる．
* ゲッターは変数の値を読み出す機能を持つメソッド．値の読み出しに制限を加えることができる．
# コンストラクタ
インスタンス化の際に呼び出される特殊なメソッド．内部変数の初期化などに利用される．
クラス名と同じ名前で定義する必要がある．
# 継承
既存のクラスに僅かな変更を加えて新たなクラスを作成したいときに使われる．
実装の際には抽象的な(共通部分のみの)クラスを作成し、継承して作成するクラスで詳細を記述することになる．
* 親クラス(スーパークラス)→
継承されるクラス
* 子クラス(サブクラス)→
親クラスを派生させて作る新たなクラス
# オーバーライド（再定義)
override=上書き(上に乗る)．親クラスのメソッドを子クラスのメソッドで再定義する．
親クラスのメソッドと同じ名前、引数(数、型、順番)、戻り値でないとオーバライドできない．
# ポリモーフィズム(多態性)
異なる内部変数やメソッドを持つオブジェクトに対して、同一のメソッド名で異なる処理を実行する
ことができる．インスタンスを差し替えるだけで類似の処理が可能になるので保守性、
可読性に優れる．
# オーバーロード
overload=多機能(上に積む)．メソッドが様々な型を引数にとって類似の機能を実現できる．
同一クラス内で同じメソッド名、異なる引数である必要がある．
# 例外
1. チェック例外
   * `java.lang.Exception`  
    配下の`java.lang.RuntimeException`だけはこれに属さないので注意．
    `IOException`(入出力異常)、`FileNotFoundException`(存在しないファイルの参照)など．
2. 非チェック例外  
`catch`するプログラムを書かなくてもコンパイルは通る．
ただし`RuntimeException`は可能な限り記述するべき．
   * `java.lang.Error`  
    メモリ不足など、普通のアプリケーションであれば内部で解決できない．
   * `java.lang.RuntimeException`  
    プログラム実行時に発生する可能性のある例外．`catch`しなければJavaVMに
    処理が移譲される．`ArithmeticException`(0で割る)、`IndexOutOfBoundsException`(範囲外参照)など．
# 修飾子とアクセス制限
1. `public` どこからでもOK
2. `protected` 同じフォルダ内(同一パッケージ内)かサブクラスならOK
3. デフォルト 同じフォルダ内ならOK(コード読むときにわかりずらいので非推奨)
4. `private` 同一クラスのみOK
5. `final` 変わらない(最終形態)  
   * クラスに付与→継承できない
   * メソッドに付与→オーバライドできない
   * フィールド変数に付与→変更できない(定数)  

[参考記事1](https://zenn.dev/miya_akari/articles/7012029ec5455d)
[参考記事2](https://java-code.jp/134)


# ArrayList
配列は宣言時に大きさを明示する必要がある．`ArrayList`は要素の追加や削除に応じて動的に
大きさを変化させる．
# イテレータ
`Iterable`インタフェースの`iterator`メソッドを実装することでイテレータオブジェクトの
取得ができるようになる．`ArraiList`にも`iterator`オブジェクトがあり、これを取得できる．
イテレータには`hasNext()`と`next()`がある．`hasNext()`は次の要素が存在するか否かを`bool`で返す．
`next()`はイテレータが保持するオブジェクトを順に取り出す．
# LinkedList
`ArrayList`は配列の一種なので途中の要素を削除すると全体を移動する必要があり、
追加削除を頻繁に行う場合データ構造として不適切である．
`LinkedList`は`sort()`を持ち、動的並び替えと相性が良い(リスト構造だから)．
# マルチスレッド
`Thread`を継承する、もしくは`Runnable`インタフェースを実装することで
複数のプログラムを実行することができる．  
共有変数など複数のスレッドから同時に参照される資源が存在する場合、
共有変数の上書きといったアクセスの競合が生じてしまう．
これを防ぐために`synchronized`修飾子によって共有資源に対して
排他的にアクセスさせる(排他的制御)．
# 抽象クラス
`abstract`修飾子を用いる．中身のメソッドに具体的な処理が書かれていない(定義のみ)．
抽象的クラスはインスタンス化することができない(未実装のため)．
抽象クラスを継承して抽象メソッドが**すべて**オーバライドによって実装されれば
継承先の子クラスとしてインスタンス化できる．なお、すべての抽象メソッドが
実装されていない場合、その子クラスもまた抽象クラスとなる．
```Java
// Figure.java
abstract class Figure {
  abstract double getArea();  // 抽象メソッド
}

// Circle.java
class Circle extends Figure {
  double radius;

  Circle(double radius) {
    this.radius = radius;
  }

  double getArea() {  // 抽象メソッドの実装
    return Math.PI * radius * radius;
  }
}
```
# インタフェース
Javaでは多重継承を認めない(1つのクラスには1つの親クラスしかない)ので、
抽象メソッドを実装するために継承をしてしまうと他のクラスを継承できなくなってしまう．
加えて、子クラスをインスタンス化したい場合、すべての抽象メソッドを
オーバライドしなければならないので不要なメソッドが存在したとしてもこれを
実装する必要がある．  
多数の抽象メソッドを持つ抽象クラス(正しくはインタフェースでありクラスではない)
から必要なクラスのみを実装したいとき、
あるいは抽象クラス以外のクラスを継承したいとき
インタフェースが有効である．
インタフェースは数多くのメソッドから目的の抽象メソッドのみ実装すること
ができる．加えてインタフェースによって実装されるインタフェース以外のクラス
を継承することができる．
インタフェースは`interface`修飾子を用いる．
```Java
public class Example implements Interface1, Interface2 {

  // Interface1の抽象メソッドmethod1を実装
  public void method1() {
    // code
  }

  // Interface2の抽象メソッドmethod2、method3を実装
  public void method2() {
    // code
  }

  public void method3() {
    // code
  }

  // 必要ならこのクラス独自のメソッドや変数を追加する
  public void exampleMethod() {
    // code
  }

}
```